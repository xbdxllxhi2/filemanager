{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, forwardRef, Component, Input, Output, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { getEditorNamespace } from 'ckeditor4-integrations-common';\n\n/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction CKEditorComponent_ng_template_0_Template(rf, ctx) {}\nlet CKEditorComponent = /*#__PURE__*/(() => {\n  class CKEditorComponent {\n    constructor(elementRef, ngZone) {\n      this.elementRef = elementRef;\n      this.ngZone = ngZone;\n      /**\n       * CKEditor 4 script url address. Script will be loaded only if CKEDITOR namespace is missing.\n       *\n       * Defaults to 'https://cdn.ckeditor.com/4.24.0-lts/standard-all/ckeditor.js'\n       */\n      this.editorUrl = 'https://cdn.ckeditor.com/4.24.0-lts/standard-all/ckeditor.js';\n      /**\n       * Tag name of the editor component.\n       *\n       * The default tag is `textarea`.\n       */\n      this.tagName = 'textarea';\n      /**\n       * The type of the editor interface.\n       *\n       * By default editor interface will be initialized as `classic` editor.\n       * You can also choose to create an editor with `inline` interface type instead.\n       *\n       * See https://ckeditor.com/docs/ckeditor4/latest/guide/dev_uitypes.html\n       * and https://ckeditor.com/docs/ckeditor4/latest/examples/fixedui.html\n       * to learn more.\n       */\n      this.type = \"classic\" /* CLASSIC */;\n      /**\n       * Fired when the CKEDITOR https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR.html namespace\n       * is loaded. It only triggers once, no matter how many CKEditor 4 components are initialised.\n       * Can be used for convenient changes in the namespace, e.g. for adding external plugins.\n       */\n      this.namespaceLoaded = new EventEmitter();\n      /**\n       * Fires when the editor is ready. It corresponds with the `editor#instanceReady`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-instanceReady\n       * event.\n       */\n      this.ready = new EventEmitter();\n      /**\n       * Fires when the editor data is loaded, e.g. after calling setData()\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#method-setData\n       * editor's method. It corresponds with the `editor#dataReady`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-dataReady event.\n       */\n      this.dataReady = new EventEmitter();\n      /**\n       * Fires when the content of the editor has changed. It corresponds with the `editor#change`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-change\n       * event. For performance reasons this event may be called even when data didn't really changed.\n       * Please note that this event will only be fired when `undo` plugin is loaded. If you need to\n       * listen for editor changes (e.g. for two-way data binding), use `dataChange` event instead.\n       */\n      this.change = new EventEmitter();\n      /**\n       * Fires when the content of the editor has changed. In contrast to `change` - only emits when\n       * data really changed thus can be successfully used with `[data]` and two way `[(data)]` binding.\n       *\n       * See more: https://angular.io/guide/template-syntax#two-way-binding---\n       */\n      this.dataChange = new EventEmitter();\n      /**\n       * Fires when the native dragStart event occurs. It corresponds with the `editor#dragstart`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-dragstart\n       * event.\n       */\n      this.dragStart = new EventEmitter();\n      /**\n       * Fires when the native dragEnd event occurs. It corresponds with the `editor#dragend`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-dragend\n       * event.\n       */\n      this.dragEnd = new EventEmitter();\n      /**\n       * Fires when the native drop event occurs. It corresponds with the `editor#drop`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-drop\n       * event.\n       */\n      this.drop = new EventEmitter();\n      /**\n       * Fires when the file loader response is received. It corresponds with the `editor#fileUploadResponse`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-fileUploadResponse\n       * event.\n       */\n      this.fileUploadResponse = new EventEmitter();\n      /**\n       * Fires when the file loader should send XHR. It corresponds with the `editor#fileUploadRequest`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-fileUploadRequest\n       * event.\n       */\n      this.fileUploadRequest = new EventEmitter();\n      /**\n       * Fires when the editing area of the editor is focused. It corresponds with the `editor#focus`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-focus\n       * event.\n       */\n      this.focus = new EventEmitter();\n      /**\n       * Fires after the user initiated a paste action, but before the data is inserted.\n       * It corresponds with the `editor#paste`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-paste\n       * event.\n       */\n      this.paste = new EventEmitter();\n      /**\n       * Fires after the `paste` event if content was modified. It corresponds with the `editor#afterPaste`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-afterPaste\n       * event.\n       */\n      this.afterPaste = new EventEmitter();\n      /**\n       * Fires when the editing view of the editor is blurred. It corresponds with the `editor#blur`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-blur\n       * event.\n       */\n      this.blur = new EventEmitter();\n      /**\n       * If the component is read–only before the editor instance is created, it remembers that state,\n       * so the editor can become read–only once it is ready.\n       */\n      this._readOnly = null;\n      this._data = null;\n      this._destroyed = false;\n    }\n    /**\n     * Keeps track of the editor's data.\n     *\n     * It's also decorated as an input which is useful when not using the ngModel.\n     *\n     * See https://angular.io/api/forms/NgModel to learn more.\n     */\n    set data(data) {\n      if (data === this._data) {\n        return;\n      }\n      if (this.instance) {\n        this.instance.setData(data);\n        // Data may be changed by ACF.\n        this._data = this.instance.getData();\n        return;\n      }\n      this._data = data;\n    }\n    get data() {\n      return this._data;\n    }\n    /**\n     * When set to `true`, the editor becomes read-only.\n     *\n     * See https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#property-readOnly\n     * to learn more.\n     */\n    set readOnly(isReadOnly) {\n      if (this.instance) {\n        this.instance.setReadOnly(isReadOnly);\n        return;\n      }\n      // Delay setting read-only state until editor initialization.\n      this._readOnly = isReadOnly;\n    }\n    get readOnly() {\n      if (this.instance) {\n        return this.instance.readOnly;\n      }\n      return this._readOnly;\n    }\n    ngAfterViewInit() {\n      getEditorNamespace(this.editorUrl, namespace => {\n        this.namespaceLoaded.emit(namespace);\n      }).then(() => {\n        // Check if component instance was destroyed before `ngAfterViewInit` call (#110).\n        // Here, `this.instance` is still not initialized and so additional flag is needed.\n        if (this._destroyed) {\n          return;\n        }\n        this.ngZone.runOutsideAngular(this.createEditor.bind(this));\n      }).catch(window.console.error);\n    }\n    ngOnDestroy() {\n      this._destroyed = true;\n      this.ngZone.runOutsideAngular(() => {\n        if (this.instance) {\n          this.instance.destroy();\n          this.instance = null;\n        }\n      });\n    }\n    writeValue(value) {\n      this.data = value;\n    }\n    registerOnChange(callback) {\n      this.onChange = callback;\n    }\n    registerOnTouched(callback) {\n      this.onTouched = callback;\n    }\n    createEditor() {\n      const element = document.createElement(this.tagName);\n      this.elementRef.nativeElement.appendChild(element);\n      const userInstanceReadyCallback = this.config?.on?.instanceReady;\n      const defaultConfig = {\n        delayIfDetached: true\n      };\n      const config = {\n        ...defaultConfig,\n        ...this.config\n      };\n      if (typeof config.on === 'undefined') {\n        config.on = {};\n      }\n      config.on.instanceReady = evt => {\n        const editor = evt.editor;\n        this.instance = editor;\n        // Read only state may change during instance initialization.\n        this.readOnly = this._readOnly !== null ? this._readOnly : this.instance.readOnly;\n        this.subscribe(this.instance);\n        const undo = editor.undoManager;\n        if (this.data !== null) {\n          undo && undo.lock();\n          editor.setData(this.data, {\n            callback: () => {\n              // Locking undoManager prevents 'change' event.\n              // Trigger it manually to updated bound data.\n              if (this.data !== editor.getData()) {\n                undo ? editor.fire('change') : editor.fire('dataReady');\n              }\n              undo && undo.unlock();\n              this.ngZone.run(() => {\n                if (typeof userInstanceReadyCallback === 'function') {\n                  userInstanceReadyCallback(evt);\n                }\n                this.ready.emit(evt);\n              });\n            }\n          });\n        } else {\n          this.ngZone.run(() => {\n            if (typeof userInstanceReadyCallback === 'function') {\n              userInstanceReadyCallback(evt);\n            }\n            this.ready.emit(evt);\n          });\n        }\n      };\n      if (this.type === \"inline\" /* INLINE */) {\n        CKEDITOR.inline(element, config);\n      } else {\n        CKEDITOR.replace(element, config);\n      }\n    }\n    subscribe(editor) {\n      editor.on('focus', evt => {\n        this.ngZone.run(() => {\n          this.focus.emit(evt);\n        });\n      });\n      editor.on('paste', evt => {\n        this.ngZone.run(() => {\n          this.paste.emit(evt);\n        });\n      });\n      editor.on('afterPaste', evt => {\n        this.ngZone.run(() => {\n          this.afterPaste.emit(evt);\n        });\n      });\n      editor.on('dragend', evt => {\n        this.ngZone.run(() => {\n          this.dragEnd.emit(evt);\n        });\n      });\n      editor.on('dragstart', evt => {\n        this.ngZone.run(() => {\n          this.dragStart.emit(evt);\n        });\n      });\n      editor.on('drop', evt => {\n        this.ngZone.run(() => {\n          this.drop.emit(evt);\n        });\n      });\n      editor.on('fileUploadRequest', evt => {\n        this.ngZone.run(() => {\n          this.fileUploadRequest.emit(evt);\n        });\n      });\n      editor.on('fileUploadResponse', evt => {\n        this.ngZone.run(() => {\n          this.fileUploadResponse.emit(evt);\n        });\n      });\n      editor.on('blur', evt => {\n        this.ngZone.run(() => {\n          if (this.onTouched) {\n            this.onTouched();\n          }\n          this.blur.emit(evt);\n        });\n      });\n      editor.on('dataReady', this.propagateChange, this);\n      if (this.instance.undoManager) {\n        editor.on('change', this.propagateChange, this);\n      }\n      // If 'undo' plugin is not loaded, listen to 'selectionCheck' event instead. (#54).\n      else {\n        editor.on('selectionCheck', this.propagateChange, this);\n      }\n    }\n    propagateChange(event) {\n      this.ngZone.run(() => {\n        const newData = this.instance.getData();\n        if (event.name === 'change') {\n          this.change.emit(event);\n        } else if (event.name === 'dataReady') {\n          this.dataReady.emit(event);\n        }\n        if (newData === this.data) {\n          return;\n        }\n        this._data = newData;\n        this.dataChange.emit(newData);\n        if (this.onChange) {\n          this.onChange(newData);\n        }\n      });\n    }\n  }\n  CKEditorComponent.ɵfac = function CKEditorComponent_Factory(t) {\n    return new (t || CKEditorComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  CKEditorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CKEditorComponent,\n    selectors: [[\"ckeditor\"]],\n    inputs: {\n      config: \"config\",\n      editorUrl: \"editorUrl\",\n      tagName: \"tagName\",\n      type: \"type\",\n      data: \"data\",\n      readOnly: \"readOnly\"\n    },\n    outputs: {\n      namespaceLoaded: \"namespaceLoaded\",\n      ready: \"ready\",\n      dataReady: \"dataReady\",\n      change: \"change\",\n      dataChange: \"dataChange\",\n      dragStart: \"dragStart\",\n      dragEnd: \"dragEnd\",\n      drop: \"drop\",\n      fileUploadResponse: \"fileUploadResponse\",\n      fileUploadRequest: \"fileUploadRequest\",\n      focus: \"focus\",\n      paste: \"paste\",\n      afterPaste: \"afterPaste\",\n      blur: \"blur\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => CKEditorComponent),\n      multi: true\n    }])],\n    decls: 1,\n    vars: 0,\n    template: function CKEditorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, CKEditorComponent_ng_template_0_Template, 0, 0, \"ng-template\");\n      }\n    },\n    encapsulation: 2\n  });\n  return CKEditorComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nlet CKEditorModule = /*#__PURE__*/(() => {\n  class CKEditorModule {}\n  CKEditorModule.ɵfac = function CKEditorModule_Factory(t) {\n    return new (t || CKEditorModule)();\n  };\n  CKEditorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CKEditorModule\n  });\n  CKEditorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[FormsModule, CommonModule]]\n  });\n  return CKEditorModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CKEditorComponent, CKEditorModule };\n//# sourceMappingURL=ckeditor4-angular.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}